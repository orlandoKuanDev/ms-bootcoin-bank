package com.example.msbootcoin.application.handler;

import com.example.msbootcoin.application.dto.*;
import com.example.msbootcoin.application.mapper.TransferenceConverter;
import com.example.msbootcoin.application.web.AcquisitionService;
import com.example.msbootcoin.domain.entity.*;
import com.example.msbootcoin.domain.service.ITransferenceService;
import com.example.msbootcoin.infrastructure.repository.IBootCoinService;
import com.example.msbootcoin.infrastructure.topic.producer.BootCoinProducer;
import com.example.msbootcoin.infrastructure.util.VerificationCodeGenerator;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

import java.net.URI;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

import static org.springframework.http.MediaType.APPLICATION_JSON;

@Slf4j
@Component
public class BootCoinHandler {
    private final IBootCoinService bootCoinService;
    private final BootCoinProducer bootCoinProducer;
    private final AcquisitionService acquisitionService;
    private final TransferenceConverter transferenceConverter;
    private final ITransferenceService transferenceService;

    @Autowired
    public BootCoinHandler(IBootCoinService bootCoinService, BootCoinProducer bootCoinProducer, AcquisitionService acquisitionService, TransferenceConverter transferenceConverter, ITransferenceService transferenceService) {
        this.bootCoinService = bootCoinService;
        this.bootCoinProducer = bootCoinProducer;
        this.acquisitionService = acquisitionService;
        this.transferenceConverter = transferenceConverter;
        this.transferenceService = transferenceService;
    }

    public Mono<ServerResponse> findAll(ServerRequest request) {
        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)
                .body(bootCoinService.findAll(), BootCoin.class);
    }
    public Mono<ServerResponse> findAllTransferees(ServerRequest request) {
        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)
                .body(transferenceService.findAll(), Transference.class);
    }
    public Mono<ServerResponse> findByVerificationCode(ServerRequest request){
        String code = request.pathVariable("code");
        return transferenceService.findByVerificationCode(code)
                .flatMap(p -> ServerResponse.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(p))
                .switchIfEmpty(Mono.error(new RuntimeException("THE BOOTCOIN DOES NOT EXIST")));
    }
    public Mono<ServerResponse> findByPhone(ServerRequest request){
        String phone = request.pathVariable("phone");
        return bootCoinService.findBootCoinByCustomer_Phone(phone)
                .flatMap(p -> ServerResponse.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(p))
                .switchIfEmpty(Mono.error(new RuntimeException("THE WALLET DOES NOT EXIST")));
    }
    public Mono<Customer> createCustomer(Mono<BootCoinCreateRequestDTO> walletRequest){
        Mono<Customer> customerForConsumer = Mono.just(new Customer());
        return walletRequest
                .zipWith(customerForConsumer, (req, customer) -> {
                    customer.setCustomerType("PERSONAL");
                    customer.setCustomerIdentityType(req.getCustomerIdentityType());
                    customer.setCustomerIdentityNumber(req.getCustomerIdentityNumber());
                    customer.setName(req.getName());
                    customer.setEmail(req.getEmail());
                    customer.setPhone(req.getPhone());
                    customer.setAddress(req.getAddress());
                    bootCoinProducer.sendSaveCustomerService(customer);
                    return customer;
                });
    }
    public Mono<ServerResponse> createBootCoin(ServerRequest request){
        Mono<BootCoinCreateRequestDTO> walletRequest = request.bodyToMono(BootCoinCreateRequestDTO.class);
        return walletRequest
                .as(this::createCustomer)
                .checkpoint("after customer create consumer")
                .delayElement(Duration.ofMillis(2000))
                .zipWhen(customer -> {
                    Acquisition createAcquisitionDTO = new Acquisition();
                    List<Customer> customers = new ArrayList<>();
                    customers.add(customer);
                    createAcquisitionDTO.setCustomerHolder(customers);
                    createAcquisitionDTO.setProduct(Product.builder()
                            .productName("BOOTCOIN").build());
                    createAcquisitionDTO.setInitial(0.0);
                    bootCoinProducer.sendSaveAcquisitionService(createAcquisitionDTO);
                    return Mono.just(createAcquisitionDTO);
                })
                .flatMap(response -> {
                    BootCoin bootCoin = new BootCoin();
                    bootCoin.setCustomer(response.getT1());
                    bootCoin.setAmountCoin(0);
                    return bootCoinService.create(bootCoin);
                })
                .flatMap(bootCoin -> ServerResponse.created(URI.create("/bootCoin/".concat(bootCoin.getId())))
                        .contentType(APPLICATION_JSON)
                        .bodyValue(bootCoin))
                .onErrorResume(error -> Mono.error(new RuntimeException(error.getMessage())));
    }

    /**
     *
     * @param request TransferenceRequestDTO
     * @return transference
     */
    public Mono<ServerResponse> transferenceBootCoinPending(ServerRequest request){
        Mono<TransferenceRequestDTO> transferRequest = request.bodyToMono(TransferenceRequestDTO.class);
        log.info("test_resques, {}", transferRequest);
        return transferRequest
                .zipWhen(transfer -> {
                    Mono<BootCoin> origenBootCoin= bootCoinService
                            .findBootCoinByCustomer_Phone(transfer.getPhoneOrigen())
                            .switchIfEmpty(Mono.error(new RuntimeException("BootCoin origen does not exist")));

                    Mono<BootCoin> destineBootCoin = bootCoinService
                            .findBootCoinByCustomer_Phone(transfer.getPhoneDestine())
                            .switchIfEmpty(Mono.error(new RuntimeException("BootCoin destine does not exist")));
                    return Mono.zip(origenBootCoin, destineBootCoin);
                })
                .flatMap(result -> {

            Double amount = result.getT1().getAmount();
            Integer coins = (int) Math.round(amount / 3.5);
            DetailsDTO detailsDTO = new DetailsDTO();
            detailsDTO.setAmount(amount);
            detailsDTO.setAmountCoin(coins);

            BootCoin seller = result.getT2().getT1();
            seller.setAmountCoin(seller.getAmountCoin() + coins);
            BootCoin buyer = result.getT2().getT2();
            buyer.setAmountCoin(seller.getAmountCoin() - coins);

            Mono<BootCoin> sellerBootCoin = Mono.just(seller);
            Mono<BootCoin> buyerBootCoin = Mono.just(buyer);
            Mono<DetailsDTO> report = Mono.just(detailsDTO);
            return Mono.zip(sellerBootCoin, buyerBootCoin, report);
        })
                .flatMap(transference -> {
                    TransferenceDTO transferenceDTO = new TransferenceDTO();
                    transferenceDTO.setSeller(transference.getT1());
                    transferenceDTO.setBuyer(transference.getT2());
                    transferenceDTO.setAmount(transference.getT3().getAmount());
                    transferenceDTO.setAmountCoin(transference.getT3().getAmountCoin());
                    transferenceDTO.setStatusTransaction("PENDING");
                    transferenceDTO.setVerificationCode(new VerificationCodeGenerator().generate("VER-",8));
                    Transference transferenceCreate = transferenceConverter.convertToEntity(transferenceDTO, new Transference());
                    return transferenceService.create(transferenceCreate);
                })
                .log()
                .flatMap(transference -> ServerResponse.created(URI.create("/transference/".concat(transference.getId())))
                        .contentType(APPLICATION_JSON)
                        .bodyValue(transference))
                .onErrorResume(error -> Mono.error(new RuntimeException(error.getMessage())));
    }

    /**
     *
     * @param request code verification code transference
     * @param request mode of pay for the transference
     * @return transference status approved
     */
    public Mono<ServerResponse> transferenceApproved(ServerRequest request){
        String code = request.pathVariable("code");
        String mode = request.pathVariable("mode");
        Mono<Transference> transferenceMono = transferenceService.findByVerificationCode(code);
        return transferenceMono
                .zipWhen(dataWallet -> {
                    if(dataWallet.getStatusTransaction().equals("APPROVED")){
                        return Mono.error(() -> new RuntimeException("your transference has already been approved"));
                    }
                    return acquisitionService
                            .findAllByCustomer(dataWallet.getSeller().getCustomer().getCustomerIdentityNumber())
                            .collectList()
                            .flatMap(acquisitions -> {
                                Acquisition origen = acquisitions.stream()
                                        .filter(acquisition -> acquisition.getProduct().getProductName().equals(mode))
                                        .findFirst()
                                        .orElseThrow(() -> new RuntimeException(String.format("you do not have an active %s", mode)));
                                CreateTransferenceDTO retire = new CreateTransferenceDTO();
                                retire.setAmount(dataWallet.getAmount());
                                retire.setAccountNumber(origen.getBill().getAccountNumber());
                                retire.setDescription(String.format("send money from %s to %s",
                                        dataWallet.getSeller().getCustomer().getPhone(),
                                        dataWallet.getBuyer().getCustomer().getPhone()));
                                retire.setCardNumber("");
                                log.info("RETIRE, {}", retire);
                                bootCoinProducer.sendSaveRetireService(retire);
                                return Mono.just(origen);
                            });
                })
                .zipWhen(dataWalletDestine -> {
                    return acquisitionService
                            .findAllByCustomer(dataWalletDestine.getT1().getBuyer().getCustomer().getCustomerIdentityNumber())
                            .collectList()
                            .flatMap(acquisitionsDestine -> {
                                Acquisition destine = acquisitionsDestine.stream()
                                        .filter(acquisition -> acquisition.getProduct().getProductName().equals(mode))
                                        .findFirst()
                                        .orElseThrow(() -> new RuntimeException(String.format("you do not have an active %s", mode)));
                                CreateTransferenceDTO deposit = new CreateTransferenceDTO();
                                deposit.setAmount(dataWalletDestine.getT1().getAmount());
                                deposit.setAccountNumber(destine.getBill().getAccountNumber());
                                deposit.setDescription(String.format("receive money from %s to %s",
                                        dataWalletDestine.getT1().getBuyer().getCustomer().getPhone(),
                                        dataWalletDestine.getT1().getSeller().getCustomer().getPhone()));
                                deposit.setCardNumber("");
                                bootCoinProducer.sendSaveDepositService(deposit);
                                return Mono.just(deposit);
                            });
                })
                .flatMap(transference -> {
                    Transference transference1 = transference.getT1().getT1();
                    transference1.setStatusTransaction("APPROVED");
                    return transferenceService.update(transference1);
                })
                .log()
                .flatMap(transference -> ServerResponse.created(URI.create("/transference/".concat(transference.getId())))
                        .contentType(APPLICATION_JSON)
                        .bodyValue(transference))
                .onErrorResume(error -> Mono.error(new RuntimeException(error.getMessage())));
    }
    public Mono<ServerResponse> accountBootCoinApproved(ServerRequest request){
        Mono<TransferencePayDTO> transferencePayDTOMono = request.bodyToMono(TransferencePayDTO.class);

        return transferencePayDTOMono
                .zipWhen(transferencePayDTO ->  transferenceService.findByVerificationCode(transferencePayDTO.getVerificationCode()))
                .zipWhen(dataWallet -> {
                    if(dataWallet.getT2().getStatusTransaction().equals("APPROVED")){
                        return Mono.error(() -> new RuntimeException("your transference has already been approved"));
                    }
                    return acquisitionService
                            .findAllByCustomer(dataWallet.getT2().getSeller().getCustomer().getCustomerIdentityNumber())
                            .collectList()
                            .flatMap(acquisitions -> {
                                Acquisition origen = acquisitions.stream()
                                        .filter(acquisition -> acquisition.getBill().getAccountNumber().equals(dataWallet.getT1().getAccountSeller()))
                                        .findFirst()
                                        .orElseThrow(() -> new RuntimeException(String.format("you do not have an account active %s", dataWallet.getT1().getAccountSeller())));
                                CreateTransferenceDTO retire = new CreateTransferenceDTO();
                                retire.setAmount(dataWallet.getT2().getAmount());
                                retire.setAccountNumber(origen.getBill().getAccountNumber());
                                retire.setDescription(String.format("send money from %s to %s",
                                        dataWallet.getT2().getSeller().getCustomer().getPhone(),
                                        dataWallet.getT2().getBuyer().getCustomer().getPhone()));
                                retire.setCardNumber("");
                                log.info("RETIRE, {}", retire);
                                bootCoinProducer.sendSaveRetireService(retire);
                                return Mono.just(origen);
                            });
                })
                .zipWhen(dataWalletDestine -> {
                    return acquisitionService
                            .findAllByCustomer(dataWalletDestine.getT1().getT2().getBuyer().getCustomer().getCustomerIdentityNumber())
                            .collectList()
                            .flatMap(acquisitionsDestine -> {
                                Acquisition destine = acquisitionsDestine.stream()
                                        .filter(acquisition -> acquisition.getBill().getAccountNumber().equals(dataWalletDestine.getT1().getT1().getAccountBuyer()))
                                        .findFirst()
                                        .orElseThrow(() -> new RuntimeException(String.format("you do not have an account active %s", dataWalletDestine.getT1().getT1().getAccountBuyer())));
                                CreateTransferenceDTO deposit = new CreateTransferenceDTO();
                                deposit.setAmount(dataWalletDestine.getT1().getT2().getAmount());
                                deposit.setAccountNumber(destine.getBill().getAccountNumber());
                                deposit.setDescription(String.format("receive money from %s to %s",
                                        dataWalletDestine.getT1().getT2().getBuyer().getCustomer().getPhone(),
                                        dataWalletDestine.getT1().getT2().getSeller().getCustomer().getPhone()));
                                deposit.setCardNumber("");
                                bootCoinProducer.sendSaveDepositService(deposit);
                                return Mono.just(deposit);
                            });
                })
                .flatMap(transference -> {
                    Transference transference1 = transference.getT1().getT1().getT2();
                    transference1.setStatusTransaction("APPROVED");
                    return transferenceService.update(transference1);
                })
                .zipWhen(dataSeller -> bootCoinService.update(dataSeller.getSeller()))
                .zipWhen(dataBuyer -> bootCoinService.update(dataBuyer.getT1().getBuyer()))
                .log()
                .flatMap(transference -> ServerResponse.created(URI.create("/transference/".concat(transference.getT1().getT1().getId())))
                        .contentType(APPLICATION_JSON)
                        .bodyValue(transference))
                .onErrorResume(error -> Mono.error(new RuntimeException(error.getMessage())));

    }
    public Mono<ServerResponse> transferenceAccBootCoinApproved(ServerRequest request){
        Mono<TransferenceRequestDTO> transferRequest = request.bodyToMono(TransferenceRequestDTO.class);
        return transferRequest
                .zipWhen(transfer -> {
                    Mono<BootCoin> origenBootCoin= bootCoinService
                            .findBootCoinByCustomer_Phone(transfer.getPhoneOrigen())
                            .switchIfEmpty(Mono.error(new RuntimeException("BootCoin origen does not exist")));

                    Mono<BootCoin> destineBootCoin = bootCoinService
                            .findBootCoinByCustomer_Phone(transfer.getPhoneDestine())
                            .switchIfEmpty(Mono.error(new RuntimeException("BootCoin destine does not exist")));
                    return Mono.zip(origenBootCoin, destineBootCoin);
                })
                .zipWhen(dataWallet -> {
                    log.info("origenBootCoin, {}", (dataWallet.getT2().getT1().getCustomer().getCustomerIdentityNumber()));
                    log.info("destineBootCoin, {}", (dataWallet.getT2().getT2().getCustomer().getCustomerIdentityNumber()));
                    return acquisitionService
                            .findAllByCustomer(dataWallet.getT2().getT1().getCustomer().getCustomerIdentityNumber())
                            .collectList()
                            .flatMap(acquisitions -> {
                                log.info("ACQUISITION_LIST, {}", acquisitions);
                                Acquisition origen = acquisitions.stream()
                                        .filter(acquisition -> acquisition.getProduct().getProductName().equals("BOOTCOIN"))
                                        .findFirst()
                                        .orElse(new Acquisition());
                                CreateTransferenceDTO retire = new CreateTransferenceDTO();
                                retire.setAmount(dataWallet.getT1().getAmount());
                                retire.setAccountNumber(origen.getBill().getAccountNumber());
                                retire.setDescription(String.format("send money from %s to %s",
                                        dataWallet.getT2().getT1().getCustomer().getPhone(),
                                        dataWallet.getT2().getT2().getCustomer().getPhone()));
                                retire.setCardNumber("");
                                log.info("RETIRE, {}", retire);
                                bootCoinProducer.sendSaveRetireService(retire);
                                return Mono.just(origen);
                            });
                })
                .zipWhen(dataWalletDestine -> {
                    return acquisitionService
                            .findAllByCustomer(dataWalletDestine.getT1().getT2().getT2().getCustomer().getCustomerIdentityNumber())
                            .collectList()
                            .flatMap(acquisitionsDestine -> {
                                Acquisition destine = acquisitionsDestine.stream()
                                        .filter(acquisition -> acquisition.getProduct().getProductName().equals("BOOTCOIN"))
                                        .findFirst()
                                        .orElse(new Acquisition());
                                CreateTransferenceDTO deposit = new CreateTransferenceDTO();
                                deposit.setAmount(dataWalletDestine.getT1().getT1().getAmount());
                                deposit.setAccountNumber(destine.getBill().getAccountNumber());
                                deposit.setDescription(String.format("receive money from %s to %s",
                                        dataWalletDestine.getT1().getT2().getT1().getCustomer().getPhone(),
                                        dataWalletDestine.getT1().getT2().getT2().getCustomer().getPhone()));
                                deposit.setCardNumber("");
                                bootCoinProducer.sendSaveDepositService(deposit);
                                return Mono.just(deposit);
                            });
                })
                .flatMap(result -> {
                    //con la cantidad calcular las gemas
                    Double amount = result.getT1().getT1().getT1().getAmount();
                    Integer coins = (int) Math.round(amount / 3.5);
                    DetailsDTO detailsDTO = new DetailsDTO();
                    detailsDTO.setAmount(amount);
                    detailsDTO.setAmountCoin(coins);

                    BootCoin seller = result.getT1().getT1().getT2().getT1();
                    //vendedor sumo coins
                    seller.setAmountCoin(seller.getAmountCoin() + coins);
                    //comprador resto coins
                    BootCoin buyer = result.getT1().getT1().getT2().getT2();
                    buyer.setAmountCoin(seller.getAmountCoin() - coins);

                    Mono<BootCoin> sellerBootCoin= bootCoinService
                            .update(seller)
                            .switchIfEmpty(Mono.error(new RuntimeException("BootCoin seller does not exist")));
                    Mono<BootCoin> buyerBootCoin= bootCoinService
                            .update(buyer)
                            .switchIfEmpty(Mono.error(new RuntimeException("BootCoin buyer does not exist")));
                    Mono<DetailsDTO> report = Mono.just(detailsDTO);
                   return Mono.zip(sellerBootCoin, buyerBootCoin, report);
                })
                .flatMap(transference -> {
                    TransferenceDTO transferenceDTO = new TransferenceDTO();
                    transferenceDTO.setSeller(transference.getT1());
                    transferenceDTO.setBuyer(transference.getT2());
                    transferenceDTO.setAmount(transference.getT3().getAmount());
                    transferenceDTO.setAmountCoin(transference.getT3().getAmountCoin());
                    Transference transferenceCreate = transferenceConverter.convertToEntity(transferenceDTO, new Transference());
                    return transferenceService.create(transferenceCreate);
                })
                .zipWhen(dataSeller -> bootCoinService.update(dataSeller.getSeller()))
                .zipWhen(dataBuyer -> bootCoinService.update(dataBuyer.getT1().getBuyer()))
                .log()
                .flatMap(transference -> ServerResponse.created(URI.create("/transference/".concat(transference.getT1().getT1().getId())))
                        .contentType(APPLICATION_JSON)
                        .bodyValue(transference.getT1().getT1()))
                .onErrorResume(error -> Mono.error(new RuntimeException(error.getMessage())));
    }

}
